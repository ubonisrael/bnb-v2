{field.value && (
                      <div className="mt-4">
                        <BreakTimesManager
                          form={form}
                          breakTimes={form.watch("break_times") || []}
                          dayId={day.id}
                        />
                      </div>
                    )}

{/* Add Off Days Manager */}
      <FormField
        control={form.control}
        name="special_off_days"
        render={({ field }) => (
          <FormItem>
            <FormControl>
              <OffDaysManager
                form={form}
                offDays={field.value || []}
                onAdd={(offDay) => {
                  const newOffDays = [...(field.value || [])];
                  const index = newOffDays.findIndex((d) => d.id === offDay.id);
                  if (index >= 0) {
                    newOffDays[index] = offDay;
                  } else {
                    newOffDays.push(offDay);
                  }
                  field.onChange(newOffDays);
                }}
                onRemove={(id) => {
                  field.onChange(
                    (field.value || []).filter((d) => d.id !== id)
                  );
                }}
              />
            </FormControl>
            <FormDescription>
              Set specific dates when your business will be closed
            </FormDescription>
          </FormItem>
        )}
      />



special_off_days: z.array(
        z.object({
          id: z.string(),
          start_date: z.string().optional(),
          dates: z.array(z.string()).optional(),
          end_date: z.string().optional(),
          reason: z.string().optional(),
          is_recurring: z.boolean().optional(),
          mode: z.enum(["single", "multiple", "range"]),
        })
      ),
      break_times: z.array(
        z.object({
          id: z.string(),
          day_of_week: z.string(),
          start_time: z.number(),
          end_time: z.number(),
          name: z.string().optional(),
        })
      )

      for (const day of days) {
        const enabled = data[`${day}_enabled`];
        const opening = data[`${day}_opening`];
        const closing = data[`${day}_closing`];

        if (enabled) {
          if (closing >= 1439) {
            ctx.addIssue({
              path: [`${day}_closing`],
              message: `${
                day.charAt(0).toUpperCase() + day.slice(1)
              } closing time must be before 11:59 PM`,
              code: z.ZodIssueCode.custom,
            });
          }

          if (closing <= opening) {
            ctx.addIssue({
              path: [`${day}_closing`],
              message: `${
                day.charAt(0).toUpperCase() + day.slice(1)
              } closing time must be later than opening time`,
              code: z.ZodIssueCode.custom,
            });
          }
        }
        // Break time checks for the current day
        const breaks = (data.break_times || []).filter(
          (b: BreakTime) => b.day_of_week.toLowerCase() === day
        );

        // Sort breaks by startTime to check for overlap
        const sortedBreaks = breaks
          .slice()
          .sort((a: BreakTime, b: BreakTime) => a.start_time - b.start_time);

        for (let i = 0; i < sortedBreaks.length; i++) {
          const curr = sortedBreaks[i];

          // Start >= End?
          if (curr.start_time >= curr.end_time) {
            ctx.addIssue({
              path: [`${day}_break_times_${i}_end_time`],
              message: `Break end time must be after start time`,
              code: z.ZodIssueCode.custom,
            });
          }

          // Start before opening?
          if (curr.start_time < opening) {
            ctx.addIssue({
              path: [`${day}_break_times_${i}_start_time`],
              message: `Break start time cannot be before ${capitalize(
                day
              )} opening time`,
              code: z.ZodIssueCode.custom,
            });
          }

          // End after closing?
          if (curr.end_time > closing) {
            ctx.addIssue({
              path: [`${day}_break_times_${i}_end_time`],
              message: `Break end time cannot be after ${capitalize(
                day
              )} closing time`,
              code: z.ZodIssueCode.custom,
            });
          }

          // Overlap with next break
          const next = sortedBreaks[i + 1];
          if (next && curr.end_time > next.start_time) {
            ctx.addIssue({
              path: [`${day}_break_times_${i}`],
              message: `Break time overlaps with another break on ${capitalize(
                day
              )}`,
              code: z.ZodIssueCode.custom,
            });
          }
        }
      }

      // SPECIAL OFF DAY VALIDATION
      const allOffDatesSet = new Set<string>();

      data.special_off_days?.forEach((offDay: OffDay, index: number) => {
        const mode = offDay.mode;
        const pathPrefix = [`special_off_days_${index}`];

        if (mode === "single") {
          if (!offDay.start_date) {
            ctx.addIssue({
              path: [`${pathPrefix}_start_date`],
              message: "start_date is required for 'single' mode",
              code: z.ZodIssueCode.custom,
            });
          }
          if (offDay.dates || offDay.end_date) {
            ctx.addIssue({
              path: [...pathPrefix],
              message:
                "'dates' and 'end_date' must not be set for 'single' mode",
              code: z.ZodIssueCode.custom,
            });
          }

          if (offDay.start_date) {
            if (allOffDatesSet.has(offDay.start_date)) {
              ctx.addIssue({
                path: [`${pathPrefix}_start_date`],
                message: `Date ${offDay.start_date} overlaps with another special off day`,
                code: z.ZodIssueCode.custom,
              });
            }
            allOffDatesSet.add(offDay.start_date);
          }
        } else if (mode === "multiple") {
          if (!offDay.dates || offDay.dates.length === 0) {
            ctx.addIssue({
              path: [`${pathPrefix}_dates`],
              message: "'dates' must be a non-empty array for 'multiple' mode",
              code: z.ZodIssueCode.custom,
            });
          }

          if (offDay.start_date || offDay.end_date) {
            ctx.addIssue({
              path: [...pathPrefix],
              message:
                "'start_date' and 'end_date' must not be set for 'multiple' mode",
              code: z.ZodIssueCode.custom,
            });
          }

          for (const date of offDay.dates || []) {
            if (allOffDatesSet.has(date)) {
              ctx.addIssue({
                path: [`${pathPrefix}_dates`],
                message: `Date ${date} overlaps with another special off day`,
                code: z.ZodIssueCode.custom,
              });
            }
            allOffDatesSet.add(date);
          }
        } else if (mode === "range") {
          if (!offDay.start_date || !offDay.end_date) {
            ctx.addIssue({
              path: [...pathPrefix],
              message:
                "Both 'start_date' and 'end_date' are required for 'range' mode",
              code: z.ZodIssueCode.custom,
            });
            return;
          }

          if (offDay.dates) {
            ctx.addIssue({
              path: [`${pathPrefix}_dates`],
              message: "'dates' must not be set for 'range' mode",
              code: z.ZodIssueCode.custom,
            });
          }

          const start = new Date(offDay.start_date);
          const end = new Date(offDay.end_date);

          if (start > end) {
            ctx.addIssue({
              path: [`${pathPrefix}_end_date`],
              message: "end_date must be after start_date",
              code: z.ZodIssueCode.custom,
            });
          } else {
            const current = new Date(start);
            while (current <= end) {
              const dateStr = current.toISOString().split("T")[0];
              if (allOffDatesSet.has(dateStr)) {
                ctx.addIssue({
                  path: [...pathPrefix],
                  message: `Date ${dateStr} overlaps with another special off day`,
                  code: z.ZodIssueCode.custom,
                });
              }
              allOffDatesSet.add(dateStr);
              current.setDate(current.getDate() + 1);
            }
          }
        }
      });
